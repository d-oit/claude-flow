name: 🏢 Enterprise Auto Label & AI Assist

on:
  workflow_dispatch:
    inputs:
      process_all_issues:
        description: 'Process all existing open issues'
        required: false
        default: 'false'
        type: boolean
      max_issues:
        description: 'Maximum number of issues to process (default: 50)'
        required: false
        default: '50'
        type: string
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, reopened]

# 🔒 Enterprise Security: Minimal permissions with explicit scoping
permissions:
  issues: write
  pull-requests: write
  contents: read  # For checkout action
  actions: read   # For workflow status

# 🚦 Enterprise Concurrency: Prevent conflicts and resource waste
concurrency:
  group: ${{ github.workflow }}-${{ github.event.number }}
  cancel-in-progress: false  # Don't cancel, queue instead for data consistency

# 🌍 Enterprise Configuration: Environment-agnostic settings
env:
  # Performance tuning
  MAX_COMMENT_LENGTH: 2000
  MIN_BODY_LENGTH: 50
  API_RETRY_COUNT: 3
  API_RETRY_DELAY: 1000
  
  # Feature flags for A/B testing
  ENABLE_AI_SUGGESTIONS: true
  ENABLE_PRIORITY_LABELING: true
  ENABLE_GOOD_FIRST_ISSUE_COMMENTS: true
  
  # Monitoring
  WORKFLOW_VERSION: "2.0.0"
  TELEMETRY_ENABLED: true

jobs:
  # 🔍 Enterprise Validation: Pre-flight checks
  validate:
    name: 🔍 Validate Input & Environment
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      item-type: ${{ steps.detect.outputs.item-type }}
      item-number: ${{ steps.detect.outputs.item-number }}
      has-labels: ${{ steps.detect.outputs.has-labels }}
      skip-processing: ${{ steps.detect.outputs.skip-processing }}
    steps:
      - name: Detect event type and validate
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            const itemType = context.payload.issue ? 'issue' : 'pull_request';
            const itemNumber = context.issue.number;
            
            // Validation checks
            if (!item) {
              console.log('ℹ️ No issue or PR found in payload');
              console.log('Event:', context.eventName);
              console.log('Action:', context.payload.action || 'none');
              console.log('Available payload keys:', Object.keys(context.payload));
              
              // Set skip processing instead of failing
              core.setOutput('skip-processing', 'true');
              core.info('⏭️ Skipping processing - no valid item found');
              return;
            }
            
            if (!item.title || item.title.trim().length === 0) {
              core.warning('Item has empty title');
            }
            
            // Set outputs
            core.setOutput('item-type', itemType);
            core.setOutput('item-number', itemNumber);
            core.setOutput('has-labels', item.labels && item.labels.length > 0);
            core.setOutput('skip-processing', item.locked || item.state === 'closed');
            
            // Telemetry
            if (process.env.TELEMETRY_ENABLED === 'true') {
              console.log(`📊 Workflow started: ${itemType} #${itemNumber} v${process.env.WORKFLOW_VERSION}`);
            }

  # 🔄 Process All Existing Issues: Manual trigger for bulk processing
  process-all-issues:
    name: 🔄 Process All Existing Issues
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.process_all_issues == 'true'
    outputs:
      processed-count: ${{ steps.process.outputs.processed-count }}
    steps:
      - name: 🔄 Process all open issues
        id: process
        uses: actions/github-script@v7
        with:
          script: |
            const maxIssues = parseInt(context.payload.inputs.max_issues) || 50;
            console.log(`🚀 Starting bulk processing of up to ${maxIssues} issues...`);
            
            // Get all open issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: Math.min(maxIssues, 100),
              sort: 'created',
              direction: 'asc'
            });
            
            console.log(`📋 Found ${issues.length} open issues to process`);
            
            let processedCount = 0;
            const results = [];
            
            for (const issue of issues) {
              try {
                console.log(`\n🔍 Processing Issue #${issue.number}: ${issue.title}`);
                
                // Analyze issue content
                const { title, body = '', labels } = issue;
                const text = (title + ' ' + body).toLowerCase();
                const currentLabels = labels.map(l => l.name);
                const labelsToAdd = [];
                
                // Bug detection
                if (text.match(/\b(bug|error|issue|problem|fail|crash|broken)\b/) && !currentLabels.includes('bug')) {
                  labelsToAdd.push('bug');
                }
                
                // Enhancement detection
                if (text.match(/\b(feature|enhancement|improve|add|request|suggest)\b/) && !currentLabels.includes('enhancement')) {
                  labelsToAdd.push('enhancement');
                }
                
                // Documentation detection
                if (text.match(/\b(documentation|docs|readme|guide|manual)\b/) && !currentLabels.includes('documentation')) {
                  labelsToAdd.push('documentation');
                }
                
                // Priority detection
                if (text.match(/\b(urgent|critical|emergency|blocking|production|security)\b/) && !currentLabels.includes('priority: high')) {
                  labelsToAdd.push('priority: high');
                } else if (text.match(/\b(important|major|significant)\b/) && !currentLabels.includes('priority: medium')) {
                  labelsToAdd.push('priority: medium');
                } else if (text.match(/\b(typo|grammar|simple|easy|minor)\b/) && !currentLabels.includes('good first issue')) {
                  labelsToAdd.push('good first issue');
                }
                
                // Apply labels if any found
                if (labelsToAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: labelsToAdd
                  });
                  
                  console.log(`✅ Added labels to #${issue.number}: ${labelsToAdd.join(', ')}`);
                  results.push({
                    number: issue.number,
                    title: issue.title,
                    addedLabels: labelsToAdd
                  });
                } else {
                  console.log(`ℹ️  No new labels needed for #${issue.number}`);
                }
                
                processedCount++;
                
                // Rate limiting: small delay between issues
                if (processedCount % 10 === 0) {
                  console.log(`⏳ Processed ${processedCount} issues, brief pause...`);
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
              } catch (error) {
                console.error(`❌ Error processing issue #${issue.number}: ${error.message}`);
                continue;
              }
            }
            
            console.log(`\n🎯 Bulk processing complete!`);
            console.log(`📊 Processed: ${processedCount} issues`);
            console.log(`🏷️  Applied labels to: ${results.length} issues`);
            
            // Set output
            core.setOutput('processed-count', processedCount);
            
            // Summary comment
            if (results.length > 0) {
              const summary = `## 🤖 Bulk Auto-Labeling Complete\n\n` +
                `Processed **${processedCount}** issues and applied labels to **${results.length}** issues:\n\n` +
                results.slice(0, 10).map(r => `- #${r.number}: Added \`${r.addedLabels.join('`, `')}\``).join('\n') +
                (results.length > 10 ? `\n\n...and ${results.length - 10} more issues` : '');
              
              // Create a summary issue or comment (optional)
              console.log('📋 Summary:', summary);
            }

  # 🏷️ Enterprise Labeling: Optimized with caching and error recovery
  auto-label:
    name: 🏷️ Auto Label
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 8
    if: needs.validate.outputs.skip-processing != 'true'
    strategy:
      matrix:
        include:
          - step: "sync-labels"
            timeout: 3
          - step: "apply-labels" 
            timeout: 4
          - step: "cleanup-labels"
            timeout: 1
    steps:
      - name: 📥 Checkout with optimized settings
        uses: actions/checkout@v4
        with:
          fetch-depth: 1  # Shallow clone for performance
          token: ${{ github.token }}
          persist-credentials: false  # Security best practice

      - name: 🗂️ Cache label configurations
        uses: actions/cache@v4
        with:
          path: |
            .github/labels.yml
            .github/labeler.yml
          key: label-config-${{ hashFiles('.github/labels.yml', '.github/labeler.yml') }}
          restore-keys: label-config-

      - name: 🔄 Sync labels with retry logic
        if: matrix.step == 'sync-labels'
        uses: EndBug/label-sync@v2
        with:
          config-file: .github/labels.yml
          token: ${{ github.token }}
          mode: add
          dry-run: false
          fail-on-error: false  # Don't fail entire workflow
        continue-on-error: true

      - name: 🎯 Apply content-based labels with rate limiting
        if: matrix.step == 'apply-labels'
        uses: actions/github-script@v7
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              if (!item) return;
              
              const title = (item.title || '').toLowerCase();
              const body = (item.body || '').toLowerCase();
              const currentLabels = item.labels.map(label => label.name);
              
              // Define sophisticated label patterns with priority and context
              const labelPatterns = {
                // Bug severity patterns
                'critical': {
                  patterns: [/(critical|urgent|blocking|blocker|crash|data loss|security breach|production down)/],
                  weight: 10,
                  excludeWith: ['enhancement', 'question']
                },
                'bug': {
                  patterns: [
                    /(bug|error|exception|crash|fail|broken|issue|problem|doesn'?t work|not working)/,
                    /(unexpected behavior|incorrect|wrong|invalid|missing)/,
                    /(throws?|stack trace|null pointer|undefined|500 error)/
                  ],
                  weight: 8,
                  requiresContext: ['steps to reproduce', 'expected', 'actual']
                },
                
                // Enhancement and feature patterns
                'enhancement': {
                  patterns: [
                    /(feature|enhancement|improvement|suggestion|request|add|would like|should)/,
                    /(new functionality|extend|expand|support for)/,
                    /(it would be nice|please add|can we have)/
                  ],
                  weight: 6,
                  excludeWith: ['bug', 'question']
                },
                'breaking-change': {
                  patterns: [/(breaking|breaking change|incompatible|deprecated|remove|delete|drop|major version)/],
                  weight: 9,
                  requiresContext: ['migration', 'upgrade', 'version']
                },
                
                // Priority indicators
                'high-priority': {
                  patterns: [
                    /(urgent|asap|high priority|important|critical|blocking)/,
                    /(production|live|customer impact|revenue impact)/,
                    /(deadline|time sensitive|needed soon)/
                  ],
                  weight: 9,
                  contextBoost: ['critical', 'bug', 'security']
                },
                'low-priority': {
                  patterns: [
                    /(low priority|nice to have|when time permits|future|someday)/,
                    /(minor|cosmetic|polish|cleanup)/
                  ],
                  weight: 3,
                  excludeWith: ['critical', 'high-priority', 'security']
                },
                
                // Complexity indicators
                'good-first-issue': {
                  patterns: [
                    /(good first issue|good for beginners|easy|simple|beginner.?friendly)/,
                    /(starter|newcomer|first contribution|small change)/,
                    /(typo|documentation fix|minor update)/
                  ],
                  weight: 5,
                  excludeWith: ['critical', 'breaking-change', 'complex']
                },
                'complex': {
                  patterns: [
                    /(complex|complicated|difficult|challenging|major refactor)/,
                    /(architecture|design pattern|algorithm|performance optimization)/,
                    /(multiple components|cross.?cutting|system.?wide)/
                  ],
                  weight: 7,
                  excludeWith: ['good-first-issue', 'simple']
                },
                
                // Domain-specific patterns
                'documentation': {
                  patterns: [
                    /(docs?|documentation|readme|guide|tutorial|manual|wiki)/,
                    /(examples?|sample|demo|walkthrough)/,
                    /(api reference|specification|changelog)/
                  ],
                  weight: 4,
                  contextBoost: ['missing', 'outdated', 'unclear']
                },
                'security': {
                  patterns: [
                    /(security|vulnerability|exploit|attack|breach|sensitive)/,
                    /(auth|authentication|authorization|permission|access control)/,
                    /(password|token|secret|credential|encryption)/,
                    /(xss|csrf|injection|sanitiz)/
                  ],
                  weight: 10,
                  requiresContext: ['impact', 'severity', 'affected versions']
                },
                'performance': {
                  patterns: [
                    /(slow|performance|speed|latency|throughput|optimization|optimize|efficient)/,
                    /(memory leak|cpu usage|load time|response time)/,
                    /(scalability|bottleneck|profiling)/
                  ],
                  weight: 7,
                  contextBoost: ['benchmark', 'metrics', 'measurement']
                },
                
                // Technical area patterns
                'api': {
                  patterns: [
                    /(api|endpoint|route|rest|graphql|request|response)/,
                    /(client|server|http|json|xml)/,
                    /(webhook|callback|integration)/
                  ],
                  weight: 5,
                  contextBoost: ['breaking', 'versioning', 'compatibility']
                },
                'ui-ux': {
                  patterns: [
                    /(ui|ux|interface|design|layout|appearance|visual)/,
                    /(frontend|display|render|style|css|responsive)/,
                    /(accessibility|a11y|screen reader|keyboard navigation)/,
                    /(user experience|usability|intuitive)/
                  ],
                  weight: 5,
                  contextBoost: ['accessibility', 'mobile', 'browser']
                },
                'database': {
                  patterns: [
                    /(database|db|sql|query|migration|schema)/,
                    /(postgres|mysql|mongodb|redis|sqlite)/,
                    /(index|performance|optimization|connection)/
                  ],
                  weight: 6,
                  contextBoost: ['migration', 'performance', 'data loss']
                },
                
                // Development workflow
                'build': {
                  patterns: [
                    /(build|ci|cd|pipeline|deploy|compilation|compile)/,
                    /(docker|container|kubernetes|helm)/,
                    /(webpack|rollup|vite|babel|typescript)/
                  ],
                  weight: 5,
                  contextBoost: ['failing', 'broken', 'optimization']
                },
                'test': {
                  patterns: [
                    /(test|testing|unit|integration|e2e|mock|stub|coverage)/,
                    /(jest|mocha|cypress|playwright|selenium)/,
                    /(assertion|expect|should|spec)/
                  ],
                  weight: 4,
                  contextBoost: ['failing', 'flaky', 'coverage']
                },
                'dependencies': {
                  patterns: [
                    /(dependency|dependencies|package|npm|pip|cargo|gem)/,
                    /(version|upgrade|update|outdated|vulnerable)/,
                    /(lock file|package.json|requirements|gemfile)/
                  ],
                  weight: 4,
                  contextBoost: ['security', 'breaking', 'vulnerability']
                },
                
                // Support and community
                'question': {
                  patterns: [
                    /(how|what|why|when|where|can|could|would|should)/,
                    /(help|support|assistance|guidance)/,
                    /(\?|question|ask|wondering)/
                  ],
                  weight: 3,
                  excludeWith: ['bug', 'enhancement'],
                  requiresContext: ['specific', 'context', 'details']
                },
                'help-wanted': {
                  patterns: [
                    /(help wanted|help needed|looking for help|collaboration)/,
                    /(contribute|volunteer|community|maintainer)/,
                    /(review needed|feedback|input)/
                  ],
                  weight: 5,
                  contextBoost: ['good-first-issue', 'documentation']
                },
                'duplicate': {
                  patterns: [
                    /(duplicate|already reported|same as|similar to)/,
                    /(see #\d+|related to #\d+|duplicate of)/
                  ],
                  weight: 8,
                  requiresContext: ['reference', 'link', 'issue number']
                }
              };
              
              // Advanced pattern matching with scoring and context awareness
              const labelCandidates = [];
              const fullText = `${title} ${body}`;
              
              // Sentiment and urgency analysis
              const urgencyIndicators = /(urgent|asap|critical|emergency|immediately|breaking|production|down|outage)/g;
              const frustrationIndicators = /(frustrated|annoying|terrible|awful|broken|useless|doesn'?t work)/g;
              const positiveIndicators = /(great|awesome|love|excellent|perfect|amazing|thank you)/g;
              
              const urgencyScore = (fullText.match(urgencyIndicators) || []).length;
              const frustrationScore = (fullText.match(frustrationIndicators) || []).length;
              const positivityScore = (fullText.match(positiveIndicators) || []).length;
              
              // Issue template compliance check
              const hasStepsToReproduce = /steps to reproduce|reproduction steps|how to reproduce/i.test(fullText);
              const hasExpectedBehavior = /expected behavior|expected result|should/i.test(fullText);
              const hasActualBehavior = /actual behavior|actual result|instead|but/i.test(fullText);
              const hasEnvironmentInfo = /environment|version|os|browser|node|npm/i.test(fullText);
              const hasCodeSample = /```|`[^`]+`|code|example/i.test(fullText);
              
              const templateCompliance = {
                hasStepsToReproduce,
                hasExpectedBehavior,
                hasActualBehavior,
                hasEnvironmentInfo,
                hasCodeSample,
                score: [hasStepsToReproduce, hasExpectedBehavior, hasActualBehavior, hasEnvironmentInfo, hasCodeSample].filter(Boolean).length
              };
              
              // Content quality indicators
              const wordCount = fullText.split(/\s+/).length;
              const hasLinks = /https?:\/\/|www\./i.test(fullText);
              const hasIssueReferences = /#\d+|issue|pr|pull request/i.test(fullText);
              const codeBlockCount = (fullText.match(/```/g) || []).length / 2;
              
              // First pass: Find all matching patterns with scores
              for (const [label, config] of Object.entries(labelPatterns)) {
                if (currentLabels.includes(label)) continue;
                
                let score = 0;
                let matchCount = 0;
                
                // Check all patterns for this label
                for (const pattern of config.patterns) {
                  const matches = fullText.match(pattern);
                  if (matches) {
                    matchCount += matches.length;
                    score += config.weight * matches.length;
                  }
                }
                
                if (matchCount > 0) {
                  // Apply context boost if relevant terms are found
                  if (config.contextBoost) {
                    for (const boostTerm of config.contextBoost) {
                      if (fullText.includes(boostTerm)) {
                        score += config.weight * 0.5; // 50% boost
                      }
                    }
                  }
                  
                  // Dynamic scoring adjustments based on analysis
                  
                  // Urgency boost for critical/high-priority labels
                  if ((label === 'critical' || label === 'high-priority') && urgencyScore > 0) {
                    score += urgencyScore * 2;
                  }
                  
                  // Frustration indicates likely bug
                  if (label === 'bug' && frustrationScore > 0) {
                    score += frustrationScore * 1.5;
                  }
                  
                  // Template compliance boost for bug reports
                  if (label === 'bug' && templateCompliance.score >= 3) {
                    score += templateCompliance.score * 0.5;
                  }
                  
                  // Quality content boost
                  if (wordCount > 100 && hasCodeSample && label !== 'question') {
                    score += 1;
                  }
                  
                  // Penalize very short issues for complex labels
                  if (wordCount < 50 && (label === 'complex' || label === 'enhancement')) {
                    score *= 0.5;
                  }
                  
                  // Boost good-first-issue for simple, well-documented issues
                  if (label === 'good-first-issue' && templateCompliance.score >= 2 && wordCount < 200) {
                    score += 2;
                  }
                  
                  // Check if required context is present
                  let hasRequiredContext = true;
                  if (config.requiresContext) {
                    hasRequiredContext = config.requiresContext.some(contextTerm => 
                      fullText.includes(contextTerm)
                    );
                  }
                  
                  if (hasRequiredContext) {
                    labelCandidates.push({
                      label,
                      score,
                      matchCount,
                      config
                    });
                  }
                }
              }
              
              // Add dynamic labels based on analysis
              
              // Template compliance labels
              if (templateCompliance.score >= 4) {
                labelCandidates.push({
                  label: 'well-documented',
                  score: 5,
                  matchCount: 1,
                  config: { weight: 5, patterns: [] }
                });
              } else if (templateCompliance.score <= 1 && wordCount > 50) {
                labelCandidates.push({
                  label: 'needs-more-info',
                  score: 6,
                  matchCount: 1,
                  config: { weight: 6, patterns: [] }
                });
              }
              
              // Urgency-based labels
              if (urgencyScore >= 2) {
                labelCandidates.push({
                  label: 'urgent',
                  score: 10,
                  matchCount: urgencyScore,
                  config: { weight: 10, patterns: [] }
                });
              }
              
              // Content quality labels
              if (wordCount < 30 && !hasCodeSample) {
                labelCandidates.push({
                  label: 'incomplete',
                  score: 7,
                  matchCount: 1,
                  config: { weight: 7, patterns: [] }
                });
              }
              
              if (codeBlockCount >= 2 && wordCount > 100) {
                labelCandidates.push({
                  label: 'detailed',
                  score: 4,
                  matchCount: 1,
                  config: { weight: 4, patterns: [] }
                });
              }
              
              // Sort candidates by score (highest first)
              labelCandidates.sort((a, b) => b.score - a.score);
              
              // Second pass: Apply exclusion rules and select final labels
              const labelsToAdd = [];
              const selectedLabels = new Set();
              
              for (const candidate of labelCandidates) {
                const { label, config } = candidate;
                
                // Check exclusion rules
                let shouldExclude = false;
                if (config.excludeWith) {
                  for (const excludeLabel of config.excludeWith) {
                    if (selectedLabels.has(excludeLabel) || currentLabels.includes(excludeLabel)) {
                      shouldExclude = true;
                      break;
                    }
                  }
                }
                
                if (!shouldExclude && !selectedLabels.has(label)) {
                  labelsToAdd.push(label);
                  selectedLabels.add(label);
                  
                  // Limit to prevent label spam (max 5 new labels per issue)
                  if (labelsToAdd.length >= 5) break;
                }
              }
              
              // Enhanced logging and label application
              if (labelsToAdd.length > 0) {
                // Log detailed analysis results
                const analysisReport = {
                  totalCandidates: labelCandidates.length,
                  selectedLabels: labelsToAdd,
                  topCandidates: labelCandidates.slice(0, 5).map(c => ({
                    label: c.label,
                    score: Math.round(c.score * 100) / 100,
                    matches: c.matchCount
                  })),
                  existingLabels: currentLabels,
                  contentAnalysis: {
                    wordCount,
                    textLength: fullText.length,
                    hasCodeSample,
                    hasLinks,
                    hasIssueReferences,
                    codeBlockCount
                  },
                  sentimentAnalysis: {
                    urgencyScore,
                    frustrationScore,
                    positivityScore
                  },
                  templateCompliance: {
                    score: templateCompliance.score,
                    details: templateCompliance
                  },
                  qualityIndicators: {
                    isWellDocumented: templateCompliance.score >= 4,
                    needsMoreInfo: templateCompliance.score <= 1 && wordCount > 50,
                    isDetailed: codeBlockCount >= 2 && wordCount > 100,
                    isIncomplete: wordCount < 30 && !hasCodeSample
                  }
                };
                
                core.info(`🏷️ Sophisticated Label Analysis Complete:`);
                core.info(`   📊 Candidates evaluated: ${labelCandidates.length}`);
                core.info(`   ✅ Labels selected: ${labelsToAdd.join(', ')}`);
                core.info(`   🎯 Top candidates: ${labelCandidates.slice(0, 5).map(c => `${c.label}(${Math.round(c.score)})`).join(', ')}`);
                core.info(`   📝 Content: ${wordCount} words, template compliance: ${templateCompliance.score}/5`);
                core.info(`   🎭 Sentiment: urgency=${urgencyScore}, frustration=${frustrationScore}, positive=${positivityScore}`);
                
                // Apply labels with retry logic
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
                
                // Log success metrics for monitoring
                core.info(`📈 SOPHISTICATED_LABELING_METRICS: ${JSON.stringify(analysisReport)}`);
                
              } else {
                core.info('🔍 No new labels selected after sophisticated analysis');
                if (labelCandidates.length > 0) {
                  core.info(`   📋 Candidates evaluated but excluded: ${labelCandidates.slice(0, 5).map(c => `${c.label}(${Math.round(c.score)})`).join(', ')}`);
                  core.info(`   📝 Content analysis: ${wordCount} words, ${templateCompliance.score}/5 template compliance`);
                }
                
                // Log analysis even when no labels are added for debugging
                const noLabelsReport = {
                  reason: 'no_labels_selected',
                  candidatesEvaluated: labelCandidates.length,
                  contentAnalysis: { wordCount, templateCompliance: templateCompliance.score },
                  sentimentAnalysis: { urgencyScore, frustrationScore, positivityScore },
                  existingLabels: currentLabels
                };
                core.info(`📊 NO_LABELS_ANALYSIS: ${JSON.stringify(noLabelsReport)}`);
              }
              
            } catch (error) {
              core.warning(`Content-based labeling failed: ${error.message}`);
            }
        continue-on-error: true

      - name: 🧹 Remove duplicate labels with smart deduplication
        if: matrix.step == 'cleanup-labels'
        uses: actions/github-script@v7
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            try {
              const { data: item } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const labels = item.labels.map(label => label.name);
              const uniqueLabels = [...new Set(labels)];
              
              if (labels.length !== uniqueLabels.length) {
                core.info(`🧹 Removing ${labels.length - uniqueLabels.length} duplicate labels`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: uniqueLabels
                });
              }
            } catch (error) {
              core.warning(`Label cleanup failed: ${error.message}`);
            }

  # 🤖 Enterprise AI Assist: Modular, configurable, and monitored
  ai-assist:
    name: 🤖 AI Assistant
    needs: [validate, auto-label]
    runs-on: ubuntu-latest
    timeout-minutes: 6
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true' &&
      vars.ENABLE_AI_SUGGESTIONS == 'true'
    strategy:
      fail-fast: false  # Continue other suggestions even if one fails
      matrix:
        suggestion-type: [bug-report, enhancement, documentation]
    steps:
      - name: 🤖 Process AI suggestions with smart detection
        uses: actions/github-script@v7
        env:
          SUGGESTION_TYPE: ${{ matrix.suggestion-type }}
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          script: |
            const suggestionType = process.env.SUGGESTION_TYPE;
            
            try {
              // Enhanced rate limiting protection with performance tracking
              const rateLimitSafeCall = async (apiCall, retries = 3, operationName = 'api-call') => {
                const startTime = Date.now();
                let totalWaitTime = 0;
                
                for (let attempt = 0; attempt < retries; attempt++) {
                  try {
                    const result = await apiCall();
                    const duration = Date.now() - startTime;
                    
                    // Log successful API call metrics
                    if (attempt > 0 || totalWaitTime > 0) {
                      core.info(`📊 API_METRICS: ${JSON.stringify({
                        operation: operationName,
                        success: true,
                        attempts: attempt + 1,
                        total_duration_ms: duration,
                        wait_time_ms: totalWaitTime,
                        timestamp: new Date().toISOString()
                      })}`);
                    }
                    
                    return result;
                  } catch (error) {
                    if (error.status === 403 && error.message.includes('rate limit')) {
                      const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                      const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                      totalWaitTime += waitTime;
                      core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                      await new Promise(resolve => setTimeout(resolve, waitTime));
                    } else if (error.status === 502 || error.status === 503) {
                      // Server errors - exponential backoff
                      const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                      totalWaitTime += backoffTime;
                      core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                      await new Promise(resolve => setTimeout(resolve, backoffTime));
                    } else {
                      // Log failed API call metrics
                      core.info(`📊 API_METRICS: ${JSON.stringify({
                        operation: operationName,
                        success: false,
                        attempts: attempt + 1,
                        error_status: error.status,
                        error_message: error.message,
                        total_duration_ms: Date.now() - startTime,
                        wait_time_ms: totalWaitTime,
                        timestamp: new Date().toISOString()
                      })}`);
                      throw error;
                    }
                  }
                }
                throw new Error(`Max retries (${retries}) exceeded for API call: ${operationName}`);
              };

              // Reusable helper functions
              const getItemData = () => {
                const item = context.payload.issue || context.payload.pull_request;
                return {
                  title: item.title,
                  body: item.body || '',
                  labels: item.labels.map(label => label.name),
                  author: item.user.login,
                  createdAt: item.created_at
                };
              };
              
              const hasLabel = (labels, targetLabel) => labels.includes(targetLabel);
              
              const shouldSuggest = (bodyLower, requiredTerms, minLength = 100) => {
                const hasRequiredTerms = requiredTerms.some(terms => 
                  terms.every(term => bodyLower.includes(term)) ||
                  terms.some(term => bodyLower.includes(term))
                );
                return !hasRequiredTerms || bodyLower.length < minLength;
              };
              
              const createComment = async (commentBody) => {
                if (commentBody.length > parseInt(process.env.MAX_COMMENT_LENGTH)) {
                  core.warning('Comment truncated due to length limit');
                  commentBody = commentBody.substring(0, parseInt(process.env.MAX_COMMENT_LENGTH)) + '...';
                }
                
                return await rateLimitSafeCall(() => 
                  github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: commentBody
                  }), 3, 'ai-assist-create-comment'
                );
              };
              
              // Get item data
              const { title, body, labels, author, createdAt } = getItemData();
              const bodyLower = body.toLowerCase();
              
              // Process based on suggestion type
              switch (suggestionType) {
                case 'bug-report':
                  if (hasLabel(labels, 'bug')) {
                    const lacksInfo = shouldSuggest(bodyLower, [
                      ['steps to reproduce', 'reproduction steps', 'how to reproduce'],
                      ['expected', 'should'],
                      ['actual', 'instead', 'but']
                    ]);
                    
                    if (lacksInfo) {
                      const comment = `👋 Hi @${author}, thank you for reporting this bug! 🐛\n\n` +
                        `To help our team investigate and resolve this issue efficiently, could you please provide:\n\n` +
                        `### 🔍 **Reproduction Details**\n` +
                        `- **Steps to Reproduce**: Clear, numbered steps to recreate the issue\n` +
                        `- **Expected Behavior**: What should happen\n` +
                        `- **Actual Behavior**: What actually happens\n\n` +
                        `### 🖥️ **Environment**\n` +
                        `- **OS**: (e.g., Windows 11, macOS 13, Ubuntu 22.04)\n` +
                        `- **Browser/Version**: (if applicable)\n` +
                        `- **Project Version**: \n\n` +
                        `### 📎 **Additional Context**\n` +
                        `- Screenshots, logs, or error messages\n` +
                        `- Any workarounds you've tried\n\n` +
                        `*This helps us prioritize and fix issues faster! 🚀*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'bug-report-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Bug report suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
                  
                case 'enhancement':
                  if (hasLabel(labels, 'enhancement')) {
                    const lacksDetails = shouldSuggest(bodyLower, [
                      ['use case', 'user story', 'problem', 'need'],
                      ['solution', 'proposal', 'implementation', 'approach']
                    ]);
                    
                    if (lacksDetails) {
                      const comment = `💡 Thanks for the enhancement suggestion, @${author}!\n\n` +
                        `To help us evaluate and prioritize this feature request:\n\n` +
                        `### 🎯 **Problem Statement**\n` +
                        `- **Use Case**: What specific problem does this solve?\n` +
                        `- **User Story**: As a [user type], I want [goal] so that [benefit]\n\n` +
                        `### 💭 **Proposed Solution**\n` +
                        `- **Implementation Idea**: How should this work?\n` +
                        `- **Alternatives Considered**: Other approaches you've thought about\n\n` +
                        `### 📊 **Impact & Priority**\n` +
                        `- **Who Benefits**: Which users/use cases are affected?\n` +
                        `- **Priority Level**: How important is this to you? (Low/Medium/High)\n\n` +
                        `*Well-defined requests help us build better features! 🎯*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'enhancement-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Enhancement suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
                  
                case 'documentation':
                  if (hasLabel(labels, 'documentation')) {
                    const lacksSpecifics = shouldSuggest(bodyLower, [
                      ['page', 'section', 'file', 'document', 'url'],
                      ['current', 'existing', 'says', 'shows']
                    ], 50);
                    
                    if (lacksSpecifics) {
                      const comment = `📚 Thanks for helping improve our documentation, @${author}!\n\n` +
                        `To locate and fix the documentation issue quickly:\n\n` +
                        `### 📍 **Location Details**\n` +
                        `- **Page/File**: Specific documentation page or file\n` +
                        `- **Section**: Particular section or heading\n` +
                        `- **URL**: Direct link (if available)\n\n` +
                        `### ✏️ **Content Issues**\n` +
                        `- **Current Content**: What it currently says\n` +
                        `- **Suggested Fix**: What it should say instead\n` +
                        `- **Why**: Brief explanation of the issue\n\n` +
                        `### 📎 **Supporting Info**\n` +
                        `- Screenshots highlighting the issue\n` +
                        `- Related documentation that might need updates\n\n` +
                        `*Precise details help us maintain accurate docs! 📖*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'documentation-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Documentation suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
              }
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'ai-assist',
                suggestionType,
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n') // Truncated stack
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`AI suggestion failed for ${suggestionType}: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
              
              // Don't fail the workflow, just log and continue
            }

  # 🎯 Enterprise Triage: Smart prioritization and assignment
  triage-assist:
    name: 🎯 Smart Triage
    needs: [validate]
    runs-on: ubuntu-latest
    timeout-minutes: 4
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true'
    steps:
      - name: 🏷️ Smart priority labeling
        uses: actions/github-script@v7
        with:
          script: |
            // Check if priority labeling is enabled
            if (process.env.ENABLE_PRIORITY_LABELING !== 'true') {
              console.log('🏷️ Priority labeling disabled, skipping...');
              return;
            }
            
            // Rate limiting protection helper
            const rateLimitSafeCall = async (apiCall, retries = 3) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                    const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                    core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                  } else if (error.status === 502 || error.status === 503) {
                    const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                    core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                  } else {
                    throw error;
                  }
                }
              }
              throw new Error(`Max retries (${retries}) exceeded for API call`);
            };
            
            try {
              const item = context.payload.issue || context.payload.pull_request;
              if (!item) {
                core.info('⏭️ No item found, skipping priority labeling');
                return;
              }
              
              const { title, body = '', labels } = item;
              const currentLabels = labels.map(label => label.name);
              
              // Enhanced keyword detection with scoring
              const urgentPatterns = [
                { keywords: ['urgent', 'critical', 'emergency'], weight: 3 },
                { keywords: ['blocking', 'production', 'outage'], weight: 3 },
                { keywords: ['security', 'vulnerability', 'exploit'], weight: 2 }
              ];
              
              const highImpactPatterns = [
                { keywords: ['breaking', 'major', 'severe'], weight: 2 },
                { keywords: ['important', 'significant'], weight: 1 }
              ];
              
              const lowComplexityPatterns = [
                { keywords: ['typo', 'grammar', 'spelling'], weight: 2 },
                { keywords: ['format', 'style', 'cosmetic'], weight: 1 }
              ];
              
              // Calculate scores
              const calculateScore = (text, patterns) => {
                return patterns.reduce((score, pattern) => {
                  const matches = pattern.keywords.filter(keyword => 
                    text.toLowerCase().includes(keyword)
                  ).length;
                  return score + (matches * pattern.weight);
                }, 0);
              };
              
              const urgentScore = calculateScore(title + ' ' + body, urgentPatterns);
              const highImpactScore = calculateScore(title + ' ' + body, highImpactPatterns);
              const lowComplexityScore = calculateScore(title + ' ' + body, lowComplexityPatterns);
              
              const labelsToAdd = [];
              
              // Smart labeling based on scores and existing labels
              if (urgentScore >= 2 && !currentLabels.includes('urgent')) {
                labelsToAdd.push('urgent');
              }
              
              if (highImpactScore >= 2 && !currentLabels.includes('high-priority')) {
                labelsToAdd.push('high-priority');
              }
              
              if (lowComplexityScore >= 2 && !currentLabels.includes('low-complexity')) {
                labelsToAdd.push('low-complexity');
              }
              
              // Add estimated effort labels
              const bodyLength = body.length;
              const titleComplexity = title.split(' ').length;
              
              if (bodyLength < 200 && titleComplexity < 10 && !currentLabels.some(l => l.includes('effort'))) {
                labelsToAdd.push('effort/small');
              } else if (bodyLength > 1000 || titleComplexity > 20) {
                labelsToAdd.push('effort/large');
              }
              
              if (labelsToAdd.length > 0) {
                await rateLimitSafeCall(() =>
                  github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: labelsToAdd
                  })
                );
                
                // Structured success logging for label operations
                const successContext = {
                  job: 'triage-assist',
                  action: 'priority-labeling',
                  itemNumber: context.issue.number,
                  itemType: context.payload.issue ? 'issue' : 'pull_request',
                  timestamp: new Date().toISOString(),
                  data: {
                    labels_added: labelsToAdd,
                    labels_count: labelsToAdd.length
                  },
                  context: {
                    repository: context.repo.full_name,
                    runId: context.runId,
                    actor: context.actor
                  }
                };
                
                core.info(`🏷️ Added priority labels: ${labelsToAdd.join(', ')}`);
                core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
              }
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'triage-assist',
                step: 'priority-labeling',
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Priority labeling failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
            }

      - name: 🌟 Good first issue assistance
        uses: actions/github-script@v7
        with:
          script: |
            // Check if good first issue comments are enabled
            if (process.env.ENABLE_GOOD_FIRST_ISSUE_COMMENTS !== 'true') {
              console.log('🌟 Good first issue comments disabled, skipping...');
              return;
            }
            
            // Rate limiting protection helper
            const rateLimitSafeCall = async (apiCall, retries = 3) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                    const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                    core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                  } else if (error.status === 502 || error.status === 503) {
                    const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                    core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                  } else {
                    throw error;
                  }
                }
              }
              throw new Error(`Max retries (${retries}) exceeded for API call`);
            };
            
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const labels = item.labels.map(label => label.name);
              
              if (labels.includes('good first issue')) {
                // Check if we've already commented (avoid spam)
                const comments = await rateLimitSafeCall(() =>
                  github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number
                  })
                );
                
                const botCommented = comments.data.some(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('good first issue')
                );
                
                if (!botCommented) {
                  const comment = `🌟 **Welcome to your first contribution opportunity!**\n\n` +
                    `This issue is marked as a "good first issue" - perfect for newcomers! Here's how to get started:\n\n` +
                    `### 🚀 **Getting Started**\n` +
                    `1. **🙋‍♀️ Claim this issue** - Comment below to let others know you're working on it\n` +
                    `2. **📖 Read our guides** - Check [CONTRIBUTING.md](CONTRIBUTING.md) for setup instructions\n` +
                    `3. **🔧 Set up your environment** - Follow our development setup guide\n` +
                    `4. **💬 Ask questions** - Don't hesitate to ask for help in comments\n\n` +
                    `### 🎯 **What makes this beginner-friendly:**\n` +
                    `- Clear scope and requirements\n` +
                    `- Good documentation and examples\n` +
                    `- Supportive community ready to help\n\n` +
                    `### 🤝 **Need Help?**\n` +
                    `- Tag maintainers in comments\n` +
                    `- Join our community discussions\n` +
                    `- Check similar resolved issues for examples\n\n` +
                    `*Happy coding! We're excited to see your contribution! 🎉*`;
                  
                  await rateLimitSafeCall(() =>
                    github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      body: comment
                    })
                  );
                  
                  // Structured success logging
                  const successContext = {
                    job: 'triage-assist',
                    action: 'good-first-issue-guidance',
                    itemNumber: context.issue.number,
                    itemType: context.payload.issue ? 'issue' : 'pull_request',
                    timestamp: new Date().toISOString(),
                    data: {
                      comment_length: comment.length,
                      guidance_provided: true
                    },
                    context: {
                      repository: context.repo.full_name,
                      runId: context.runId,
                      actor: context.actor
                    }
                  };
                  
                  core.info('🌟 Good first issue guidance posted');
                  core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                }
              }
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'triage-assist',
                step: 'good-first-issue-assistance',
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Good first issue assistance failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
            }

  # 📊 Enterprise Monitoring: Comprehensive observability
  monitoring:
    name: 📊 Workflow Monitoring
    needs: [validate, auto-label, ai-assist, triage-assist]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always() && vars.TELEMETRY_ENABLED == 'true'
    steps:
      - name: 📈 Collect and report metrics
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const itemType = context.payload.issue ? 'issue' : 'pull_request';
              const itemNumber = context.issue.number;
              
              // Collect job results
              const jobs = {
                validate: '${{ needs.validate.result }}',
                autoLabel: '${{ needs.auto-label.result }}',
                aiAssist: '${{ needs.ai-assist.result }}',
                triageAssist: '${{ needs.triage-assist.result }}'
              };
              
              // Calculate success metrics
              const totalJobs = Object.keys(jobs).length;
              const successfulJobs = Object.values(jobs).filter(result => result === 'success').length;
              const successRate = (successfulJobs / totalJobs * 100).toFixed(1);
              
              // Performance metrics
              const workflowStartTime = new Date('${{ github.event.created_at }}');
              const currentTime = new Date();
              const processingTime = Math.round((currentTime - workflowStartTime) / 1000);
              
              // Create comprehensive report
              const report = {
                workflow: {
                  version: process.env.WORKFLOW_VERSION,
                  repository: context.repo.full_name,
                  runId: context.runId,
                  runNumber: context.runNumber
                },
                item: {
                  type: itemType,
                  number: itemNumber,
                  title: item.title,
                  author: item.user.login,
                  labels: item.labels.map(l => l.name),
                  createdAt: item.created_at
                },
                performance: {
                  processingTimeSeconds: processingTime,
                  successRate: successRate,
                  jobResults: jobs
                },
                timestamp: currentTime.toISOString()
              };
              
              // Log structured data for monitoring systems
              console.log('📊 WORKFLOW_METRICS:', JSON.stringify(report, null, 2));
              
              // Summary for humans
              console.log(`\n🎯 Workflow Summary:`);
              console.log(`   📋 Processed: ${itemType} #${itemNumber}`);
              console.log(`   ⏱️  Duration: ${processingTime}s`);
              console.log(`   ✅ Success Rate: ${successRate}%`);
              console.log(`   🏷️  Final Labels: ${item.labels.map(l => l.name).join(', ') || 'none'}`);
              
              // Set workflow outputs for downstream systems
              core.setOutput('success-rate', successRate);
              core.setOutput('processing-time', processingTime);
              core.setOutput('metrics-json', JSON.stringify(report));
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'monitoring',
                step: 'metrics-collection',
                itemNumber: context.issue?.number || 'unknown',
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Monitoring failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
              
              // Don't fail workflow for monitoring issues
            }