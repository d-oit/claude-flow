name: 🏢 Enterprise Auto Label & AI Assist

on:
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, reopened]

# 🔒 Enterprise Security: Minimal permissions with explicit scoping
permissions:
  issues: write
  pull-requests: write
  contents: read  # For checkout action
  actions: read   # For workflow status

# 🚦 Enterprise Concurrency: Prevent conflicts and resource waste
concurrency:
  group: ${{ github.workflow }}-${{ github.event.number }}
  cancel-in-progress: false  # Don't cancel, queue instead for data consistency

# 🌍 Enterprise Configuration: Environment-agnostic settings
env:
  # Performance tuning
  MAX_COMMENT_LENGTH: 2000
  MIN_BODY_LENGTH: 50
  API_RETRY_COUNT: 3
  API_RETRY_DELAY: 1000
  
  # Feature flags for A/B testing
  ENABLE_AI_SUGGESTIONS: true
  ENABLE_PRIORITY_LABELING: true
  ENABLE_GOOD_FIRST_ISSUE_COMMENTS: true
  
  # Monitoring
  WORKFLOW_VERSION: "2.0.0"
  TELEMETRY_ENABLED: true

jobs:
  # 🔍 Enterprise Validation: Pre-flight checks
  validate:
    name: 🔍 Validate Input & Environment
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      item-type: ${{ steps.detect.outputs.item-type }}
      item-number: ${{ steps.detect.outputs.item-number }}
      has-labels: ${{ steps.detect.outputs.has-labels }}
      skip-processing: ${{ steps.detect.outputs.skip-processing }}
    steps:
      - name: Detect event type and validate
        id: detect
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            const itemType = context.payload.issue ? 'issue' : 'pull_request';
            const itemNumber = context.issue.number;
            
            // Validation checks
            if (!item) {
              core.setFailed('No valid issue or PR found in payload');
              return;
            }
            
            if (!item.title || item.title.trim().length === 0) {
              core.warning('Item has empty title');
            }
            
            // Set outputs
            core.setOutput('item-type', itemType);
            core.setOutput('item-number', itemNumber);
            core.setOutput('has-labels', item.labels && item.labels.length > 0);
            core.setOutput('skip-processing', item.locked || item.state === 'closed');
            
            // Telemetry
            if (process.env.TELEMETRY_ENABLED === 'true') {
              console.log(`📊 Workflow started: ${itemType} #${itemNumber} v${process.env.WORKFLOW_VERSION}`);
            }

  # 🏷️ Enterprise Labeling: Optimized with caching and error recovery
  auto-label:
    name: 🏷️ Auto Label
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 8
    if: needs.validate.outputs.skip-processing != 'true'
    strategy:
      matrix:
        include:
          - step: "sync-labels"
            timeout: 3
          - step: "apply-labels" 
            timeout: 4
          - step: "cleanup-labels"
            timeout: 1
    steps:
      - name: 📥 Checkout with optimized settings
        uses: actions/checkout@v4
        with:
          fetch-depth: 1  # Shallow clone for performance
          token: ${{ github.token }}
          persist-credentials: false  # Security best practice

      - name: 🗂️ Cache label configurations
        uses: actions/cache@v4
        with:
          path: |
            .github/labels.yml
            .github/labeler.yml
          key: label-config-${{ hashFiles('.github/labels.yml', '.github/labeler.yml') }}
          restore-keys: label-config-

      - name: 🔄 Sync labels with retry logic
        if: matrix.step == 'sync-labels'
        uses: EndBug/label-sync@v2
        with:
          config-file: .github/labels.yml
          token: ${{ github.token }}
          mode: add
          dry-run: false
          fail-on-error: false  # Don't fail entire workflow
        continue-on-error: true

      - name: 🎯 Apply regex-based labels with rate limiting
        if: matrix.step == 'apply-labels'
        uses: github/issue-labeler@v3
        with:
          configuration-path: .github/labeler.yml
          include-title: 1
          include-body: 1
          sync-labels: 0
          repo-token: ${{ github.token }}
          exclude-labels: 'duplicate,wontfix,invalid,closed'
          dry-run: false
        continue-on-error: true

      - name: 🧹 Remove duplicate labels with smart deduplication
        if: matrix.step == 'cleanup-labels'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            try {
              const { data: item } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const labels = item.labels.map(label => label.name);
              const uniqueLabels = [...new Set(labels)];
              
              if (labels.length !== uniqueLabels.length) {
                core.info(`🧹 Removing ${labels.length - uniqueLabels.length} duplicate labels`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: uniqueLabels
                });
              }
            } catch (error) {
              core.warning(`Label cleanup failed: ${error.message}`);
            }

  # 🤖 Enterprise AI Assist: Modular, configurable, and monitored
  ai-assist:
    name: 🤖 AI Assistant
    needs: [validate, auto-label]
    runs-on: ubuntu-latest
    timeout-minutes: 6
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true' &&
      vars.ENABLE_AI_SUGGESTIONS == 'true'
    strategy:
      fail-fast: false  # Continue other suggestions even if one fails
      matrix:
        suggestion-type: [bug-report, enhancement, documentation]
    steps:
      - name: 🤖 Process AI suggestions with smart detection
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          SUGGESTION_TYPE: ${{ matrix.suggestion-type }}
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          script: |
            const suggestionType = process.env.SUGGESTION_TYPE;
            
            try {
              // Enhanced rate limiting protection with performance tracking
              const rateLimitSafeCall = async (apiCall, retries = 3, operationName = 'api-call') => {
                const startTime = Date.now();
                let totalWaitTime = 0;
                
                for (let attempt = 0; attempt < retries; attempt++) {
                  try {
                    const result = await apiCall();
                    const duration = Date.now() - startTime;
                    
                    // Log successful API call metrics
                    if (attempt > 0 || totalWaitTime > 0) {
                      core.info(`📊 API_METRICS: ${JSON.stringify({
                        operation: operationName,
                        success: true,
                        attempts: attempt + 1,
                        total_duration_ms: duration,
                        wait_time_ms: totalWaitTime,
                        timestamp: new Date().toISOString()
                      })}`);
                    }
                    
                    return result;
                  } catch (error) {
                    if (error.status === 403 && error.message.includes('rate limit')) {
                      const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                      const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                      totalWaitTime += waitTime;
                      core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                      await new Promise(resolve => setTimeout(resolve, waitTime));
                    } else if (error.status === 502 || error.status === 503) {
                      // Server errors - exponential backoff
                      const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                      totalWaitTime += backoffTime;
                      core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                      await new Promise(resolve => setTimeout(resolve, backoffTime));
                    } else {
                      // Log failed API call metrics
                      core.info(`📊 API_METRICS: ${JSON.stringify({
                        operation: operationName,
                        success: false,
                        attempts: attempt + 1,
                        error_status: error.status,
                        error_message: error.message,
                        total_duration_ms: Date.now() - startTime,
                        wait_time_ms: totalWaitTime,
                        timestamp: new Date().toISOString()
                      })}`);
                      throw error;
                    }
                  }
                }
                throw new Error(`Max retries (${retries}) exceeded for API call: ${operationName}`);
              };

              // Reusable helper functions
              const getItemData = () => {
                const item = context.payload.issue || context.payload.pull_request;
                return {
                  title: item.title,
                  body: item.body || '',
                  labels: item.labels.map(label => label.name),
                  author: item.user.login,
                  createdAt: item.created_at
                };
              };
              
              const hasLabel = (labels, targetLabel) => labels.includes(targetLabel);
              
              const shouldSuggest = (bodyLower, requiredTerms, minLength = 100) => {
                const hasRequiredTerms = requiredTerms.some(terms => 
                  terms.every(term => bodyLower.includes(term)) ||
                  terms.some(term => bodyLower.includes(term))
                );
                return !hasRequiredTerms || bodyLower.length < minLength;
              };
              
              const createComment = async (commentBody) => {
                if (commentBody.length > parseInt(process.env.MAX_COMMENT_LENGTH)) {
                  core.warning('Comment truncated due to length limit');
                  commentBody = commentBody.substring(0, parseInt(process.env.MAX_COMMENT_LENGTH)) + '...';
                }
                
                return await rateLimitSafeCall(() => 
                  github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: commentBody
                  }), 3, 'ai-assist-create-comment'
                );
              };
              
              // Get item data
              const { title, body, labels, author, createdAt } = getItemData();
              const bodyLower = body.toLowerCase();
              
              // Process based on suggestion type
              switch (suggestionType) {
                case 'bug-report':
                  if (hasLabel(labels, 'bug')) {
                    const lacksInfo = shouldSuggest(bodyLower, [
                      ['steps to reproduce', 'reproduction steps', 'how to reproduce'],
                      ['expected', 'should'],
                      ['actual', 'instead', 'but']
                    ]);
                    
                    if (lacksInfo) {
                      const comment = `👋 Hi @${author}, thank you for reporting this bug! 🐛\n\n` +
                        `To help our team investigate and resolve this issue efficiently, could you please provide:\n\n` +
                        `### 🔍 **Reproduction Details**\n` +
                        `- **Steps to Reproduce**: Clear, numbered steps to recreate the issue\n` +
                        `- **Expected Behavior**: What should happen\n` +
                        `- **Actual Behavior**: What actually happens\n\n` +
                        `### 🖥️ **Environment**\n` +
                        `- **OS**: (e.g., Windows 11, macOS 13, Ubuntu 22.04)\n` +
                        `- **Browser/Version**: (if applicable)\n` +
                        `- **Project Version**: \n\n` +
                        `### 📎 **Additional Context**\n` +
                        `- Screenshots, logs, or error messages\n` +
                        `- Any workarounds you've tried\n\n` +
                        `*This helps us prioritize and fix issues faster! 🚀*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'bug-report-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Bug report suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
                  
                case 'enhancement':
                  if (hasLabel(labels, 'enhancement')) {
                    const lacksDetails = shouldSuggest(bodyLower, [
                      ['use case', 'user story', 'problem', 'need'],
                      ['solution', 'proposal', 'implementation', 'approach']
                    ]);
                    
                    if (lacksDetails) {
                      const comment = `💡 Thanks for the enhancement suggestion, @${author}!\n\n` +
                        `To help us evaluate and prioritize this feature request:\n\n` +
                        `### 🎯 **Problem Statement**\n` +
                        `- **Use Case**: What specific problem does this solve?\n` +
                        `- **User Story**: As a [user type], I want [goal] so that [benefit]\n\n` +
                        `### 💭 **Proposed Solution**\n` +
                        `- **Implementation Idea**: How should this work?\n` +
                        `- **Alternatives Considered**: Other approaches you've thought about\n\n` +
                        `### 📊 **Impact & Priority**\n` +
                        `- **Who Benefits**: Which users/use cases are affected?\n` +
                        `- **Priority Level**: How important is this to you? (Low/Medium/High)\n\n` +
                        `*Well-defined requests help us build better features! 🎯*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'enhancement-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Enhancement suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
                  
                case 'documentation':
                  if (hasLabel(labels, 'documentation')) {
                    const lacksSpecifics = shouldSuggest(bodyLower, [
                      ['page', 'section', 'file', 'document', 'url'],
                      ['current', 'existing', 'says', 'shows']
                    ], 50);
                    
                    if (lacksSpecifics) {
                      const comment = `📚 Thanks for helping improve our documentation, @${author}!\n\n` +
                        `To locate and fix the documentation issue quickly:\n\n` +
                        `### 📍 **Location Details**\n` +
                        `- **Page/File**: Specific documentation page or file\n` +
                        `- **Section**: Particular section or heading\n` +
                        `- **URL**: Direct link (if available)\n\n` +
                        `### ✏️ **Content Issues**\n` +
                        `- **Current Content**: What it currently says\n` +
                        `- **Suggested Fix**: What it should say instead\n` +
                        `- **Why**: Brief explanation of the issue\n\n` +
                        `### 📎 **Supporting Info**\n` +
                        `- Screenshots highlighting the issue\n` +
                        `- Related documentation that might need updates\n\n` +
                        `*Precise details help us maintain accurate docs! 📖*`;
                      
                      const startTime = Date.now();
                      await createComment(comment);
                      const duration = Date.now() - startTime;
                      
                      // Structured success logging
                      const successContext = {
                        job: 'ai-assist',
                        action: 'documentation-suggestion',
                        itemNumber: context.issue.number,
                        itemType: context.payload.issue ? 'issue' : 'pull_request',
                        timestamp: new Date().toISOString(),
                        performance: {
                          duration_ms: duration,
                          comment_length: comment.length
                        },
                        context: {
                          repository: context.repo.full_name,
                          runId: context.runId,
                          actor: context.actor
                        }
                      };
                      
                      core.info('🤖 Documentation suggestion posted');
                      core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                    }
                  }
                  break;
              }
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'ai-assist',
                suggestionType,
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n') // Truncated stack
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`AI suggestion failed for ${suggestionType}: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
              
              // Don't fail the workflow, just log and continue
            }

  # 🎯 Enterprise Triage: Smart prioritization and assignment
  triage-assist:
    name: 🎯 Smart Triage
    needs: [validate]
    runs-on: ubuntu-latest
    timeout-minutes: 4
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true'
    steps:
      - name: 🏷️ Smart priority labeling
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            // Check if priority labeling is enabled
            if (process.env.ENABLE_PRIORITY_LABELING !== 'true') {
              console.log('🏷️ Priority labeling disabled, skipping...');
              return;
            }
            
            // Rate limiting protection helper
            const rateLimitSafeCall = async (apiCall, retries = 3) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                    const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                    core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                  } else if (error.status === 502 || error.status === 503) {
                    const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                    core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                  } else {
                    throw error;
                  }
                }
              }
              throw new Error(`Max retries (${retries}) exceeded for API call`);
            };
            
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const { title, body = '', labels } = item;
              const currentLabels = labels.map(label => label.name);
              
              // Enhanced keyword detection with scoring
              const urgentPatterns = [
                { keywords: ['urgent', 'critical', 'emergency'], weight: 3 },
                { keywords: ['blocking', 'production', 'outage'], weight: 3 },
                { keywords: ['security', 'vulnerability', 'exploit'], weight: 2 }
              ];
              
              const highImpactPatterns = [
                { keywords: ['breaking', 'major', 'severe'], weight: 2 },
                { keywords: ['important', 'significant'], weight: 1 }
              ];
              
              const lowComplexityPatterns = [
                { keywords: ['typo', 'grammar', 'spelling'], weight: 2 },
                { keywords: ['format', 'style', 'cosmetic'], weight: 1 }
              ];
              
              // Calculate scores
              const calculateScore = (text, patterns) => {
                return patterns.reduce((score, pattern) => {
                  const matches = pattern.keywords.filter(keyword => 
                    text.toLowerCase().includes(keyword)
                  ).length;
                  return score + (matches * pattern.weight);
                }, 0);
              };
              
              const urgentScore = calculateScore(title + ' ' + body, urgentPatterns);
              const highImpactScore = calculateScore(title + ' ' + body, highImpactPatterns);
              const lowComplexityScore = calculateScore(title + ' ' + body, lowComplexityPatterns);
              
              const labelsToAdd = [];
              
              // Smart labeling based on scores and existing labels
              if (urgentScore >= 2 && !currentLabels.includes('urgent')) {
                labelsToAdd.push('urgent');
              }
              
              if (highImpactScore >= 2 && !currentLabels.includes('high-priority')) {
                labelsToAdd.push('high-priority');
              }
              
              if (lowComplexityScore >= 2 && !currentLabels.includes('low-complexity')) {
                labelsToAdd.push('low-complexity');
              }
              
              // Add estimated effort labels
              const bodyLength = body.length;
              const titleComplexity = title.split(' ').length;
              
              if (bodyLength < 200 && titleComplexity < 10 && !currentLabels.some(l => l.includes('effort'))) {
                labelsToAdd.push('effort/small');
              } else if (bodyLength > 1000 || titleComplexity > 20) {
                labelsToAdd.push('effort/large');
              }
              
              if (labelsToAdd.length > 0) {
                await rateLimitSafeCall(() =>
                  github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: labelsToAdd
                  })
                );
                
                // Structured success logging for label operations
                const successContext = {
                  job: 'triage-assist',
                  action: 'priority-labeling',
                  itemNumber: context.issue.number,
                  itemType: context.payload.issue ? 'issue' : 'pull_request',
                  timestamp: new Date().toISOString(),
                  data: {
                    labels_added: labelsToAdd,
                    labels_count: labelsToAdd.length
                  },
                  context: {
                    repository: context.repo.full_name,
                    runId: context.runId,
                    actor: context.actor
                  }
                };
                
                core.info(`🏷️ Added priority labels: ${labelsToAdd.join(', ')}`);
                core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
              }
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'triage-assist',
                step: 'priority-labeling',
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Priority labeling failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
            }

      - name: 🌟 Good first issue assistance
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            // Check if good first issue comments are enabled
            if (process.env.ENABLE_GOOD_FIRST_ISSUE_COMMENTS !== 'true') {
              console.log('🌟 Good first issue comments disabled, skipping...');
              return;
            }
            
            // Rate limiting protection helper
            const rateLimitSafeCall = async (apiCall, retries = 3) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit')) {
                    const resetTime = error.response?.headers?.['x-ratelimit-reset'];
                    const waitTime = resetTime ? Math.min((resetTime * 1000) - Date.now(), 60000) : 30000;
                    core.info(`⏳ Rate limited, waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                  } else if (error.status === 502 || error.status === 503) {
                    const backoffTime = Math.min(1000 * Math.pow(2, attempt), 30000);
                    core.info(`🔄 Server error, retrying in ${backoffTime/1000}s (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                  } else {
                    throw error;
                  }
                }
              }
              throw new Error(`Max retries (${retries}) exceeded for API call`);
            };
            
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const labels = item.labels.map(label => label.name);
              
              if (labels.includes('good first issue')) {
                // Check if we've already commented (avoid spam)
                const comments = await rateLimitSafeCall(() =>
                  github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number
                  })
                );
                
                const botCommented = comments.data.some(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('good first issue')
                );
                
                if (!botCommented) {
                  const comment = `🌟 **Welcome to your first contribution opportunity!**\n\n` +
                    `This issue is marked as a "good first issue" - perfect for newcomers! Here's how to get started:\n\n` +
                    `### 🚀 **Getting Started**\n` +
                    `1. **🙋‍♀️ Claim this issue** - Comment below to let others know you're working on it\n` +
                    `2. **📖 Read our guides** - Check [CONTRIBUTING.md](CONTRIBUTING.md) for setup instructions\n` +
                    `3. **🔧 Set up your environment** - Follow our development setup guide\n` +
                    `4. **💬 Ask questions** - Don't hesitate to ask for help in comments\n\n` +
                    `### 🎯 **What makes this beginner-friendly:**\n` +
                    `- Clear scope and requirements\n` +
                    `- Good documentation and examples\n` +
                    `- Supportive community ready to help\n\n` +
                    `### 🤝 **Need Help?**\n` +
                    `- Tag maintainers in comments\n` +
                    `- Join our community discussions\n` +
                    `- Check similar resolved issues for examples\n\n` +
                    `*Happy coding! We're excited to see your contribution! 🎉*`;
                  
                  await rateLimitSafeCall(() =>
                    github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      body: comment
                    })
                  );
                  
                  // Structured success logging
                  const successContext = {
                    job: 'triage-assist',
                    action: 'good-first-issue-guidance',
                    itemNumber: context.issue.number,
                    itemType: context.payload.issue ? 'issue' : 'pull_request',
                    timestamp: new Date().toISOString(),
                    data: {
                      comment_length: comment.length,
                      guidance_provided: true
                    },
                    context: {
                      repository: context.repo.full_name,
                      runId: context.runId,
                      actor: context.actor
                    }
                  };
                  
                  core.info('🌟 Good first issue guidance posted');
                  core.info(`📊 SUCCESS_METRICS: ${JSON.stringify(successContext, null, 2)}`);
                }
              }
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'triage-assist',
                step: 'good-first-issue-assistance',
                itemNumber: context.issue.number,
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Good first issue assistance failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
            }

  # 📊 Enterprise Monitoring: Comprehensive observability
  monitoring:
    name: 📊 Workflow Monitoring
    needs: [validate, auto-label, ai-assist, triage-assist]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always() && vars.TELEMETRY_ENABLED == 'true'
    steps:
      - name: 📈 Collect and report metrics
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const itemType = context.payload.issue ? 'issue' : 'pull_request';
              const itemNumber = context.issue.number;
              
              // Collect job results
              const jobs = {
                validate: '${{ needs.validate.result }}',
                autoLabel: '${{ needs.auto-label.result }}',
                aiAssist: '${{ needs.ai-assist.result }}',
                triageAssist: '${{ needs.triage-assist.result }}'
              };
              
              // Calculate success metrics
              const totalJobs = Object.keys(jobs).length;
              const successfulJobs = Object.values(jobs).filter(result => result === 'success').length;
              const successRate = (successfulJobs / totalJobs * 100).toFixed(1);
              
              // Performance metrics
              const workflowStartTime = new Date('${{ github.event.created_at }}');
              const currentTime = new Date();
              const processingTime = Math.round((currentTime - workflowStartTime) / 1000);
              
              // Create comprehensive report
              const report = {
                workflow: {
                  version: process.env.WORKFLOW_VERSION,
                  repository: context.repo.full_name,
                  runId: context.runId,
                  runNumber: context.runNumber
                },
                item: {
                  type: itemType,
                  number: itemNumber,
                  title: item.title,
                  author: item.user.login,
                  labels: item.labels.map(l => l.name),
                  createdAt: item.created_at
                },
                performance: {
                  processingTimeSeconds: processingTime,
                  successRate: successRate,
                  jobResults: jobs
                },
                timestamp: currentTime.toISOString()
              };
              
              // Log structured data for monitoring systems
              console.log('📊 WORKFLOW_METRICS:', JSON.stringify(report, null, 2));
              
              // Summary for humans
              console.log(`\n🎯 Workflow Summary:`);
              console.log(`   📋 Processed: ${itemType} #${itemNumber}`);
              console.log(`   ⏱️  Duration: ${processingTime}s`);
              console.log(`   ✅ Success Rate: ${successRate}%`);
              console.log(`   🏷️  Final Labels: ${item.labels.map(l => l.name).join(', ') || 'none'}`);
              
              // Set workflow outputs for downstream systems
              core.setOutput('success-rate', successRate);
              core.setOutput('processing-time', processingTime);
              core.setOutput('metrics-json', JSON.stringify(report));
              
            } catch (error) {
              // Structured error logging for observability
              const errorContext = {
                job: 'monitoring',
                step: 'metrics-collection',
                itemNumber: context.issue?.number || 'unknown',
                itemType: context.payload.issue ? 'issue' : 'pull_request',
                timestamp: new Date().toISOString(),
                error: {
                  message: error.message,
                  status: error.status,
                  stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                context: {
                  repository: context.repo.full_name,
                  runId: context.runId,
                  actor: context.actor
                }
              };
              
              core.error(`Monitoring failed: ${error.message}`);
              core.info(`🔍 ERROR_CONTEXT: ${JSON.stringify(errorContext, null, 2)}`);
              
              // Don't fail workflow for monitoring issues
            }