name: ðŸ¢ Enterprise Auto Label & AI Assist

on:
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, reopened]

# ðŸ”’ Enterprise Security: Minimal permissions with explicit scoping
permissions:
  issues: write
  pull-requests: write
  contents: read  # For checkout action
  actions: read   # For workflow status

# ðŸš¦ Enterprise Concurrency: Prevent conflicts and resource waste
concurrency:
  group: ${{ github.workflow }}-${{ github.event.number }}
  cancel-in-progress: false  # Don't cancel, queue instead for data consistency

# ðŸŒ Enterprise Configuration: Environment-agnostic settings
env:
  # Performance tuning
  MAX_COMMENT_LENGTH: 2000
  MIN_BODY_LENGTH: 50
  API_RETRY_COUNT: 3
  API_RETRY_DELAY: 1000
  
  # Feature flags for A/B testing
  ENABLE_AI_SUGGESTIONS: true
  ENABLE_PRIORITY_LABELING: true
  ENABLE_GOOD_FIRST_ISSUE_COMMENTS: true
  
  # Monitoring
  WORKFLOW_VERSION: "2.0.0"
  TELEMETRY_ENABLED: true

jobs:
  # ðŸ” Enterprise Validation: Pre-flight checks
  validate:
    name: ðŸ” Validate Input & Environment
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      item-type: ${{ steps.detect.outputs.item-type }}
      item-number: ${{ steps.detect.outputs.item-number }}
      has-labels: ${{ steps.detect.outputs.has-labels }}
      skip-processing: ${{ steps.detect.outputs.skip-processing }}
    steps:
      - name: Detect event type and validate
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            const itemType = context.payload.issue ? 'issue' : 'pull_request';
            const itemNumber = context.issue.number;
            
            // Validation checks
            if (!item) {
              core.setFailed('No valid issue or PR found in payload');
              return;
            }
            
            if (!item.title || item.title.trim().length === 0) {
              core.warning('Item has empty title');
            }
            
            // Set outputs
            core.setOutput('item-type', itemType);
            core.setOutput('item-number', itemNumber);
            core.setOutput('has-labels', item.labels && item.labels.length > 0);
            core.setOutput('skip-processing', item.locked || item.state === 'closed');
            
            // Telemetry
            if (process.env.TELEMETRY_ENABLED === 'true') {
              console.log(`ðŸ“Š Workflow started: ${itemType} #${itemNumber} v${process.env.WORKFLOW_VERSION}`);
            }

  # ðŸ·ï¸ Enterprise Labeling: Optimized with caching and error recovery
  auto-label:
    name: ðŸ·ï¸ Auto Label
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 8
    if: needs.validate.outputs.skip-processing != 'true'
    strategy:
      matrix:
        include:
          - step: "sync-labels"
            timeout: 3
          - step: "apply-labels" 
            timeout: 4
          - step: "cleanup-labels"
            timeout: 1
    steps:
      - name: ðŸ“¥ Checkout with optimized settings
        uses: actions/checkout@v4
        with:
          fetch-depth: 1  # Shallow clone for performance
          token: ${{ github.token }}
          persist-credentials: false  # Security best practice

      - name: ðŸ—‚ï¸ Cache label configurations
        uses: actions/cache@v4
        with:
          path: |
            .github/labels.yml
            .github/labeler.yml
          key: label-config-${{ hashFiles('.github/labels.yml', '.github/labeler.yml') }}
          restore-keys: label-config-

      - name: ðŸ”„ Sync labels with retry logic
        if: matrix.step == 'sync-labels'
        uses: EndBug/label-sync@v2
        with:
          config-file: .github/labels.yml
          token: ${{ github.token }}
          mode: add
          dry-run: false
          fail-on-error: false  # Don't fail entire workflow
        continue-on-error: true

      - name: ðŸŽ¯ Apply regex-based labels with rate limiting
        if: matrix.step == 'apply-labels'
        uses: github/issue-labeler@v3
        with:
          configuration-path: .github/labeler.yml
          include-title: 1
          include-body: 1
          sync-labels: 0
          repo-token: ${{ github.token }}
          exclude-labels: 'duplicate,wontfix,invalid,closed'
          dry-run: false
        continue-on-error: true

      - name: ðŸ§¹ Remove duplicate labels with smart deduplication
        if: matrix.step == 'cleanup-labels'
        uses: actions/github-script@v7
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            try {
              const { data: item } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const labels = item.labels.map(label => label.name);
              const uniqueLabels = [...new Set(labels)];
              
              if (labels.length !== uniqueLabels.length) {
                core.info(`ðŸ§¹ Removing ${labels.length - uniqueLabels.length} duplicate labels`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: uniqueLabels
                });
              }
            } catch (error) {
              core.warning(`Label cleanup failed: ${error.message}`);
            }

  # ðŸ¤– Enterprise AI Assist: Modular, configurable, and monitored
  ai-assist:
    name: ðŸ¤– AI Assistant
    needs: [validate, auto-label]
    runs-on: ubuntu-latest
    timeout-minutes: 6
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true' &&
      env.ENABLE_AI_SUGGESTIONS == 'true'
    strategy:
      fail-fast: false  # Continue other suggestions even if one fails
      matrix:
        suggestion-type: [bug-report, enhancement, documentation]
    steps:
      - name: ðŸ¤– Process AI suggestions with smart detection
        uses: actions/github-script@v7
        env:
          SUGGESTION_TYPE: ${{ matrix.suggestion-type }}
        with:
          retries: ${{ env.API_RETRY_COUNT }}
          script: |
            const suggestionType = process.env.SUGGESTION_TYPE;
            
            try {
              // Reusable helper functions
              const getItemData = () => {
                const item = context.payload.issue || context.payload.pull_request;
                return {
                  title: item.title,
                  body: item.body || '',
                  labels: item.labels.map(label => label.name),
                  author: item.user.login,
                  createdAt: item.created_at
                };
              };
              
              const hasLabel = (labels, targetLabel) => labels.includes(targetLabel);
              
              const shouldSuggest = (bodyLower, requiredTerms, minLength = 100) => {
                const hasRequiredTerms = requiredTerms.some(terms => 
                  terms.every(term => bodyLower.includes(term)) ||
                  terms.some(term => bodyLower.includes(term))
                );
                return !hasRequiredTerms || bodyLower.length < minLength;
              };
              
              const createComment = async (commentBody) => {
                if (commentBody.length > parseInt(process.env.MAX_COMMENT_LENGTH)) {
                  core.warning('Comment truncated due to length limit');
                  commentBody = commentBody.substring(0, parseInt(process.env.MAX_COMMENT_LENGTH)) + '...';
                }
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
              };
              
              // Get item data
              const { title, body, labels, author, createdAt } = getItemData();
              const bodyLower = body.toLowerCase();
              
              // Process based on suggestion type
              switch (suggestionType) {
                case 'bug-report':
                  if (hasLabel(labels, 'bug')) {
                    const lacksInfo = shouldSuggest(bodyLower, [
                      ['steps to reproduce', 'reproduction steps', 'how to reproduce'],
                      ['expected', 'should'],
                      ['actual', 'instead', 'but']
                    ]);
                    
                    if (lacksInfo) {
                      const comment = `ðŸ‘‹ Hi @${author}, thank you for reporting this bug! ðŸ›\n\n` +
                        `To help our team investigate and resolve this issue efficiently, could you please provide:\n\n` +
                        `### ðŸ” **Reproduction Details**\n` +
                        `- **Steps to Reproduce**: Clear, numbered steps to recreate the issue\n` +
                        `- **Expected Behavior**: What should happen\n` +
                        `- **Actual Behavior**: What actually happens\n\n` +
                        `### ðŸ–¥ï¸ **Environment**\n` +
                        `- **OS**: (e.g., Windows 11, macOS 13, Ubuntu 22.04)\n` +
                        `- **Browser/Version**: (if applicable)\n` +
                        `- **Project Version**: \n\n` +
                        `### ðŸ“Ž **Additional Context**\n` +
                        `- Screenshots, logs, or error messages\n` +
                        `- Any workarounds you've tried\n\n` +
                        `*This helps us prioritize and fix issues faster! ðŸš€*`;
                      
                      await createComment(comment);
                      core.info('ðŸ¤– Bug report suggestion posted');
                    }
                  }
                  break;
                  
                case 'enhancement':
                  if (hasLabel(labels, 'enhancement')) {
                    const lacksDetails = shouldSuggest(bodyLower, [
                      ['use case', 'user story', 'problem', 'need'],
                      ['solution', 'proposal', 'implementation', 'approach']
                    ]);
                    
                    if (lacksDetails) {
                      const comment = `ðŸ’¡ Thanks for the enhancement suggestion, @${author}!\n\n` +
                        `To help us evaluate and prioritize this feature request:\n\n` +
                        `### ðŸŽ¯ **Problem Statement**\n` +
                        `- **Use Case**: What specific problem does this solve?\n` +
                        `- **User Story**: As a [user type], I want [goal] so that [benefit]\n\n` +
                        `### ðŸ’­ **Proposed Solution**\n` +
                        `- **Implementation Idea**: How should this work?\n` +
                        `- **Alternatives Considered**: Other approaches you've thought about\n\n` +
                        `### ðŸ“Š **Impact & Priority**\n` +
                        `- **Who Benefits**: Which users/use cases are affected?\n` +
                        `- **Priority Level**: How important is this to you? (Low/Medium/High)\n\n` +
                        `*Well-defined requests help us build better features! ðŸŽ¯*`;
                      
                      await createComment(comment);
                      core.info('ðŸ¤– Enhancement suggestion posted');
                    }
                  }
                  break;
                  
                case 'documentation':
                  if (hasLabel(labels, 'documentation')) {
                    const lacksSpecifics = shouldSuggest(bodyLower, [
                      ['page', 'section', 'file', 'document', 'url'],
                      ['current', 'existing', 'says', 'shows']
                    ], 50);
                    
                    if (lacksSpecifics) {
                      const comment = `ðŸ“š Thanks for helping improve our documentation, @${author}!\n\n` +
                        `To locate and fix the documentation issue quickly:\n\n` +
                        `### ðŸ“ **Location Details**\n` +
                        `- **Page/File**: Specific documentation page or file\n` +
                        `- **Section**: Particular section or heading\n` +
                        `- **URL**: Direct link (if available)\n\n` +
                        `### âœï¸ **Content Issues**\n` +
                        `- **Current Content**: What it currently says\n` +
                        `- **Suggested Fix**: What it should say instead\n` +
                        `- **Why**: Brief explanation of the issue\n\n` +
                        `### ðŸ“Ž **Supporting Info**\n` +
                        `- Screenshots highlighting the issue\n` +
                        `- Related documentation that might need updates\n\n` +
                        `*Precise details help us maintain accurate docs! ðŸ“–*`;
                      
                      await createComment(comment);
                      core.info('ðŸ¤– Documentation suggestion posted');
                    }
                  }
                  break;
              }
              
            } catch (error) {
              core.error(`AI suggestion failed for ${suggestionType}: ${error.message}`);
              // Don't fail the workflow, just log and continue
            }

  # ðŸŽ¯ Enterprise Triage: Smart prioritization and assignment
  triage-assist:
    name: ðŸŽ¯ Smart Triage
    needs: [validate, auto-label]
    runs-on: ubuntu-latest
    timeout-minutes: 4
    if: |
      always() && 
      needs.validate.outputs.skip-processing != 'true'
    steps:
      - name: ðŸ·ï¸ Smart priority labeling
        if: env.ENABLE_PRIORITY_LABELING == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const { title, body = '', labels } = item;
              const currentLabels = labels.map(label => label.name);
              
              // Enhanced keyword detection with scoring
              const urgentPatterns = [
                { keywords: ['urgent', 'critical', 'emergency'], weight: 3 },
                { keywords: ['blocking', 'production', 'outage'], weight: 3 },
                { keywords: ['security', 'vulnerability', 'exploit'], weight: 2 }
              ];
              
              const highImpactPatterns = [
                { keywords: ['breaking', 'major', 'severe'], weight: 2 },
                { keywords: ['important', 'significant'], weight: 1 }
              ];
              
              const lowComplexityPatterns = [
                { keywords: ['typo', 'grammar', 'spelling'], weight: 2 },
                { keywords: ['format', 'style', 'cosmetic'], weight: 1 }
              ];
              
              // Calculate scores
              const calculateScore = (text, patterns) => {
                return patterns.reduce((score, pattern) => {
                  const matches = pattern.keywords.filter(keyword => 
                    text.toLowerCase().includes(keyword)
                  ).length;
                  return score + (matches * pattern.weight);
                }, 0);
              };
              
              const urgentScore = calculateScore(title + ' ' + body, urgentPatterns);
              const highImpactScore = calculateScore(title + ' ' + body, highImpactPatterns);
              const lowComplexityScore = calculateScore(title + ' ' + body, lowComplexityPatterns);
              
              const labelsToAdd = [];
              
              // Smart labeling based on scores and existing labels
              if (urgentScore >= 2 && !currentLabels.includes('urgent')) {
                labelsToAdd.push('urgent');
              }
              
              if (highImpactScore >= 2 && !currentLabels.includes('high-priority')) {
                labelsToAdd.push('high-priority');
              }
              
              if (lowComplexityScore >= 2 && !currentLabels.includes('low-complexity')) {
                labelsToAdd.push('low-complexity');
              }
              
              // Add estimated effort labels
              const bodyLength = body.length;
              const titleComplexity = title.split(' ').length;
              
              if (bodyLength < 200 && titleComplexity < 10 && !currentLabels.some(l => l.includes('effort'))) {
                labelsToAdd.push('effort/small');
              } else if (bodyLength > 1000 || titleComplexity > 20) {
                labelsToAdd.push('effort/large');
              }
              
              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
                
                core.info(`ðŸ·ï¸ Added priority labels: ${labelsToAdd.join(', ')}`);
              }
              
            } catch (error) {
              core.error(`Priority labeling failed: ${error.message}`);
            }

      - name: ðŸŒŸ Good first issue assistance
        if: env.ENABLE_GOOD_FIRST_ISSUE_COMMENTS == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const labels = item.labels.map(label => label.name);
              
              if (labels.includes('good first issue')) {
                // Check if we've already commented (avoid spam)
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number
                });
                
                const botCommented = comments.data.some(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('good first issue')
                );
                
                if (!botCommented) {
                  const comment = `ðŸŒŸ **Welcome to your first contribution opportunity!**\n\n` +
                    `This issue is marked as a "good first issue" - perfect for newcomers! Here's how to get started:\n\n` +
                    `### ðŸš€ **Getting Started**\n` +
                    `1. **ðŸ™‹â€â™€ï¸ Claim this issue** - Comment below to let others know you're working on it\n` +
                    `2. **ðŸ“– Read our guides** - Check [CONTRIBUTING.md](CONTRIBUTING.md) for setup instructions\n` +
                    `3. **ðŸ”§ Set up your environment** - Follow our development setup guide\n` +
                    `4. **ðŸ’¬ Ask questions** - Don't hesitate to ask for help in comments\n\n` +
                    `### ðŸŽ¯ **What makes this beginner-friendly:**\n` +
                    `- Clear scope and requirements\n` +
                    `- Good documentation and examples\n` +
                    `- Supportive community ready to help\n\n` +
                    `### ðŸ¤ **Need Help?**\n` +
                    `- Tag maintainers in comments\n` +
                    `- Join our community discussions\n` +
                    `- Check similar resolved issues for examples\n\n` +
                    `*Happy coding! We're excited to see your contribution! ðŸŽ‰*`;
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: comment
                  });
                  
                  core.info('ðŸŒŸ Good first issue guidance posted');
                }
              }
            } catch (error) {
              core.error(`Good first issue assistance failed: ${error.message}`);
            }

  # ðŸ“Š Enterprise Monitoring: Comprehensive observability
  monitoring:
    name: ðŸ“Š Workflow Monitoring
    needs: [validate, auto-label, ai-assist, triage-assist]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always() && env.TELEMETRY_ENABLED == 'true'
    steps:
      - name: ðŸ“ˆ Collect and report metrics
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const item = context.payload.issue || context.payload.pull_request;
              const itemType = context.payload.issue ? 'issue' : 'pull_request';
              const itemNumber = context.issue.number;
              
              // Collect job results
              const jobs = {
                validate: '${{ needs.validate.result }}',
                autoLabel: '${{ needs.auto-label.result }}',
                aiAssist: '${{ needs.ai-assist.result }}',
                triageAssist: '${{ needs.triage-assist.result }}'
              };
              
              // Calculate success metrics
              const totalJobs = Object.keys(jobs).length;
              const successfulJobs = Object.values(jobs).filter(result => result === 'success').length;
              const successRate = (successfulJobs / totalJobs * 100).toFixed(1);
              
              // Performance metrics
              const workflowStartTime = new Date('${{ github.event.created_at }}');
              const currentTime = new Date();
              const processingTime = Math.round((currentTime - workflowStartTime) / 1000);
              
              // Create comprehensive report
              const report = {
                workflow: {
                  version: process.env.WORKFLOW_VERSION,
                  repository: context.repo.full_name,
                  runId: context.runId,
                  runNumber: context.runNumber
                },
                item: {
                  type: itemType,
                  number: itemNumber,
                  title: item.title,
                  author: item.user.login,
                  labels: item.labels.map(l => l.name),
                  createdAt: item.created_at
                },
                performance: {
                  processingTimeSeconds: processingTime,
                  successRate: successRate,
                  jobResults: jobs
                },
                timestamp: currentTime.toISOString()
              };
              
              // Log structured data for monitoring systems
              console.log('ðŸ“Š WORKFLOW_METRICS:', JSON.stringify(report, null, 2));
              
              // Summary for humans
              console.log(`\nðŸŽ¯ Workflow Summary:`);
              console.log(`   ðŸ“‹ Processed: ${itemType} #${itemNumber}`);
              console.log(`   â±ï¸  Duration: ${processingTime}s`);
              console.log(`   âœ… Success Rate: ${successRate}%`);
              console.log(`   ðŸ·ï¸  Final Labels: ${item.labels.map(l => l.name).join(', ') || 'none'}`);
              
              // Set workflow outputs for downstream systems
              core.setOutput('success-rate', successRate);
              core.setOutput('processing-time', processingTime);
              core.setOutput('metrics-json', JSON.stringify(report));
              
            } catch (error) {
              core.error(`Monitoring failed: ${error.message}`);
              // Don't fail workflow for monitoring issues
            }